Build an order execution engine that processes ONE order type (market,
limit, or sniper - your choice) with DEX routing and WebSocket status updates. You must create a real devnet execution

How It Works - Order Execution Flow
Order Submission
User submits order via POST /api/orders/execute
API validates order and returns orderId
Same HTTP connection upgrades to WebSocket for live updates
Briefly document **why** you chose that order type and outline (1-2 sentences in README) how the same engine can be extended to support the other two.

DEX Routing
System fetches quotes from both Raydium and Meteora pools
Compares prices and selects best execution venue
Routes order to DEX with better price/liquidity

Execution Progress (via WebSocket)


"pending" - Order received and queued
"routing" - Comparing DEX prices
"building" - Creating transaction
"submitted" - Transaction sent to network
"confirmed" - Transaction successful (includes txHash)
"failed" - If any step fails (includes error)

Transaction Settlement


Executes swap on chosen DEX (Raydium/Meteora)
Handles slippage protection
Returns final execution price and transaction hash


Real Devnet Execution (Bonus Points)
Use actual Raydium/Meteora SDKs
Execute real trades on devnet
Deal with network latency and failures

Resources & References for real devnet
Solana Libraries: @solana/web3.js, @solana/spl-token
DEX SDKs: @raydium-io/raydium-sdk-v2, @meteora-ag/dynamic-amm-sdk
Docs:
Raydium: https://github.com/raydium-io/raydium-sdk-V2-demo 
Meteora: https://docs.meteora.ag/ 
devnet: https://faucet.solana.com


Core Requirements
Order Types (Choose ONE)


Market Order - Immediate execution at current price
Limit Order - Execute when target price reached
Sniper Order - Execute on token launch/migration

DEX Router Implementation


Query both Raydium and Meteora for quotes
Route to best price automatically
Handle wrapped SOL for native token swaps
Log routing decisions for transparency

HTTP → WebSocket Pattern


Single endpoint handles both protocols
Initial POST returns orderId
Connection upgrades to WebSocket for status streaming

Concurrent Processing


Queue system managing up to 10 concurrent orders
Process 100 orders/minute
Exponential back-off retry (≤3 attempts). If still unsuccessful, emit "failed" status and persist failure reason for post-mortem analysis


Allowed TECH STACK
Tech Stack
Node.js + TypeScript
Fastify (WebSocket support built-in)
BullMQ + Redis (order queue)
PostgreSQL (order history) + Redis (active orders)


Deliverables
GitHub repo with clean commits. Make sure to commit changes to github, after completing a certain task. This is must. 
API with order execution and routing
WebSocket status updates
Transaction proof (Solana Explorer link)
Link to GitHub docs/readme with basic documentation explaining design decisions and setup instructions
Deploy to free hosting - include public URL in README
1-2 min public youtube video link that shows functionality
Order flow through your system and design decisions
Submit 3-5 orders simultaneously
WebSocket showing all status updates (pending → routing → confirmed)
DEX routing decisions in logs/console
Queue processing multiple orders 
✅ Postman/Insomnia collection **plus** ≥10 unit/integration tests covering routing logic, queue behaviour, and WebSocket lifecycle
